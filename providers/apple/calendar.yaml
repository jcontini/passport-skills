# Apple Calendar â†’ Calendar tool mapping
# Uses Swift/EventKit for full calendar access with async permissions

actions:
  calendars:
    label: "List calendars"
    description: List all available calendars
    swift:
      script: |
        import EventKit
        import Foundation
        
        let store = EKEventStore()
        let semaphore = DispatchSemaphore(value: 0)
        var accessGranted = false
        
        if #available(macOS 14.0, *) {
            store.requestFullAccessToEvents { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        } else {
            store.requestAccess(to: .event) { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        }
        semaphore.wait()
        
        guard accessGranted else {
            fputs("{\"error\": \"Calendar access denied\"}\n", stderr)
            exit(1)
        }
        
        let calendars = store.calendars(for: .event)
        var output: [[String: Any]] = []
        
        for cal in calendars {
            var dict: [String: Any] = [
                "id": cal.calendarIdentifier,
                "name": cal.title
            ]
            if let cgColor = cal.cgColor {
                let r = Int((cgColor.components?[0] ?? 0) * 255)
                let g = Int((cgColor.components?[1] ?? 0) * 255)
                let b = Int((cgColor.components?[2] ?? 0) * 255)
                dict["color"] = String(format: "#%02X%02X%02X", r, g, b)
            }
            dict["is_readonly"] = !cal.allowsContentModifications
            output.append(dict)
        }
        
        if let jsonData = try? JSONSerialization.data(withJSONObject: output, options: []),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            print(jsonString)
        } else {
            print("[]")
        }
      response:
        mapping:
          id: "[].id"
          name: "[].name"
          color: "[].color"
          is_readonly: "[].is_readonly"
          connector: "'apple'"

  list:
    label: "List events"
    description: List calendar events within a date range
    params:
      days: { type: number, default: 7, description: "Days from today (1-30)" }
      past: { type: boolean, default: false, description: "Look backward instead of forward" }
      calendar_id: { type: string, description: "Filter by calendar name (partial match)" }
      query: { type: string, description: "Search title, location, or description" }
      limit: { type: number, default: 50 }
      exclude_all_day: { type: boolean, default: false, description: "Exclude all-day events" }
    swift:
      script: |
        import EventKit
        import Foundation
        
        let store = EKEventStore()
        let semaphore = DispatchSemaphore(value: 0)
        var accessGranted = false
        
        if #available(macOS 14.0, *) {
            store.requestFullAccessToEvents { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        } else {
            store.requestAccess(to: .event) { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        }
        semaphore.wait()
        
        guard accessGranted else {
            fputs("{\"error\": \"Calendar access denied. Grant in System Settings > Privacy > Calendars\"}\n", stderr)
            exit(1)
        }
        
        // Parse arguments
        let args = CommandLine.arguments
        let days = args.count > 1 ? Int(args[1]) ?? 7 : 7
        let past = args.count > 2 && args[2] == "true"
        let calendarFilter = args.count > 3 && args[3] != "" ? args[3].lowercased() : nil
        let titleQuery = args.count > 4 && args[4] != "" ? args[4].lowercased() : nil
        let limit = args.count > 5 && args[5] != "" ? Int(args[5]) : nil
        let excludeAllDay = args.count > 6 && args[6] == "true"
        
        // Date range
        let calendar = Calendar.current
        let now = Date()
        let startOfDay = calendar.startOfDay(for: now)
        
        let startDate: Date
        let endDate: Date
        if past {
            startDate = calendar.date(byAdding: .day, value: -days, to: startOfDay)!
            endDate = now
        } else {
            startDate = startOfDay
            endDate = calendar.date(byAdding: .day, value: days, to: startOfDay)!
        }
        
        // Filter calendars
        var calendarsToSearch: [EKCalendar]? = nil
        if let filter = calendarFilter {
            calendarsToSearch = store.calendars(for: .event).filter {
                $0.title.lowercased().contains(filter)
            }
        }
        
        // Query events
        let predicate = store.predicateForEvents(withStart: startDate, end: endDate, calendars: calendarsToSearch)
        var events = store.events(matching: predicate)
        
        // Filter all-day
        if excludeAllDay {
            events = events.filter { !$0.isAllDay }
        }
        
        // Filter by query
        if let query = titleQuery {
            events = events.filter {
                ($0.title ?? "").lowercased().contains(query) ||
                ($0.location ?? "").lowercased().contains(query) ||
                ($0.notes ?? "").lowercased().contains(query)
            }
        }
        
        // Sort
        if past {
            events.sort { $0.startDate > $1.startDate }
        } else {
            events.sort { $0.startDate < $1.startDate }
        }
        
        // Limit
        if let lim = limit, lim > 0 {
            events = Array(events.prefix(lim))
        }
        
        // Formatters
        let isoFormatter = ISO8601DateFormatter()
        isoFormatter.formatOptions = [.withInternetDateTime]
        
        // Build JSON
        var output: [[String: Any]] = []
        for event in events {
            var dict: [String: Any] = [
                "id": event.eventIdentifier ?? "",
                "title": event.title ?? "",
                "start": isoFormatter.string(from: event.startDate),
                "end": isoFormatter.string(from: event.endDate),
                "all_day": event.isAllDay,
                "calendar_id": event.calendar.calendarIdentifier,
                "calendar_name": event.calendar.title
            ]
            if let location = event.location, !location.isEmpty {
                dict["location"] = location
            }
            if let notes = event.notes, !notes.isEmpty {
                dict["description"] = notes
            }
            if event.hasAttendees, let attendees = event.attendees {
                dict["attendees"] = attendees.map { attendee in
                    var a: [String: Any] = ["name": attendee.name ?? ""]
                    if attendee.url.scheme == "mailto" {
                        a["email"] = attendee.url.absoluteString.replacingOccurrences(of: "mailto:", with: "")
                    }
                    switch attendee.participantStatus {
                    case .accepted: a["status"] = "accepted"
                    case .declined: a["status"] = "declined"
                    case .tentative: a["status"] = "tentative"
                    default: a["status"] = "pending"
                    }
                    return a
                }
            }
            if event.hasRecurrenceRules, let rules = event.recurrenceRules, let rule = rules.first {
                dict["recurrence"] = ["rule": rule.description]
            }
            output.append(dict)
        }
        
        if let jsonData = try? JSONSerialization.data(withJSONObject: output, options: []),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            print(jsonString)
        } else {
            print("[]")
        }
      args:
        - "{{params.days | default: 7}}"
        - "{{params.past | default: false}}"
        - "{{params.calendar_id}}"
        - "{{params.query}}"
        - "{{params.limit | default: 50}}"
        - "{{params.exclude_all_day | default: false}}"
      response:
        mapping:
          id: "[].id"
          title: "[].title"
          description: "[].description"
          start: "[].start"
          end: "[].end"
          all_day: "[].all_day"
          location: "[].location"
          calendar:
            id: "[].calendar_id"
            name: "[].calendar_name"
          attendees: "[].attendees"
          recurrence: "[].recurrence"
          connector: "'apple'"

  get:
    label: "Get event"
    description: Get full details of a specific event
    params:
      id: { type: string, required: true, description: "Event ID" }
    swift:
      script: |
        import EventKit
        import Foundation
        
        let store = EKEventStore()
        let semaphore = DispatchSemaphore(value: 0)
        var accessGranted = false
        
        if #available(macOS 14.0, *) {
            store.requestFullAccessToEvents { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        } else {
            store.requestAccess(to: .event) { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        }
        semaphore.wait()
        
        guard accessGranted else {
            fputs("{\"error\": \"Calendar access denied\"}\n", stderr)
            exit(1)
        }
        
        let uid = CommandLine.arguments.count > 1 ? CommandLine.arguments[1] : ""
        guard !uid.isEmpty, let event = store.event(withIdentifier: uid) else {
            fputs("{\"error\": \"Event not found\"}\n", stderr)
            exit(1)
        }
        
        let isoFormatter = ISO8601DateFormatter()
        isoFormatter.formatOptions = [.withInternetDateTime]
        
        var dict: [String: Any] = [
            "id": event.eventIdentifier ?? "",
            "title": event.title ?? "",
            "start": isoFormatter.string(from: event.startDate),
            "end": isoFormatter.string(from: event.endDate),
            "all_day": event.isAllDay,
            "calendar_id": event.calendar.calendarIdentifier,
            "calendar_name": event.calendar.title
        ]
        if let location = event.location, !location.isEmpty {
            dict["location"] = location
        }
        if let notes = event.notes, !notes.isEmpty {
            dict["description"] = notes
        }
        if let url = event.url {
            dict["url"] = url.absoluteString
        }
        if event.hasAttendees, let attendees = event.attendees {
            dict["attendees"] = attendees.map { attendee in
                var a: [String: Any] = ["name": attendee.name ?? ""]
                if attendee.url.scheme == "mailto" {
                    a["email"] = attendee.url.absoluteString.replacingOccurrences(of: "mailto:", with: "")
                }
                switch attendee.participantStatus {
                case .accepted: a["status"] = "accepted"
                case .declined: a["status"] = "declined"
                case .tentative: a["status"] = "tentative"
                default: a["status"] = "pending"
                }
                a["optional"] = !attendee.isCurrentUser && attendee.participantRole == .optional
                return a
            }
        }
        if event.hasRecurrenceRules, let rules = event.recurrenceRules {
            dict["recurrence"] = ["rule": rules.map { $0.description }.joined(separator: ";")]
        }
        if event.hasAlarms, let alarms = event.alarms {
            dict["reminders"] = alarms.map { Int($0.relativeOffset / 60) }
        }
        
        if let jsonData = try? JSONSerialization.data(withJSONObject: dict, options: [.prettyPrinted]),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            print(jsonString)
        }
      args:
        - "{{params.id}}"
      response:
        mapping:
          id: ".id"
          title: ".title"
          description: ".description"
          start: ".start"
          end: ".end"
          all_day: ".all_day"
          location: ".location"
          url: ".url"
          calendar:
            id: ".calendar_id"
            name: ".calendar_name"
          attendees: ".attendees"
          recurrence: ".recurrence"
          connector: "'apple'"

  create:
    label: "Create event"
    description: Create a new calendar event
    params:
      title: { type: string, required: true, description: "Event title" }
      start: { type: string, required: true, description: "Start (YYYY-MM-DD HH:MM or YYYY-MM-DD)" }
      end: { type: string, description: "End (defaults to 1 hour after start)" }
      all_day: { type: boolean, description: "Create as all-day event" }
      location: { type: string, description: "Event location" }
      description: { type: string, description: "Event description/notes" }
      calendar_id: { type: string, description: "Target calendar name (partial match)" }
    swift:
      script: |
        import EventKit
        import Foundation
        
        let store = EKEventStore()
        let semaphore = DispatchSemaphore(value: 0)
        var accessGranted = false
        
        if #available(macOS 14.0, *) {
            store.requestFullAccessToEvents { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        } else {
            store.requestAccess(to: .event) { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        }
        semaphore.wait()
        
        guard accessGranted else {
            fputs("{\"error\": \"Calendar access denied\"}\n", stderr)
            exit(1)
        }
        
        // Parse arguments
        let args = CommandLine.arguments
        guard args.count > 2 else {
            fputs("{\"error\": \"title and start required\"}\n", stderr)
            exit(1)
        }
        
        let title = args[1]
        let startStr = args[2]
        let endStr = args.count > 3 && args[3] != "" ? args[3] : ""
        let calName = args.count > 4 && args[4] != "" ? args[4] : ""
        let location = args.count > 5 && args[5] != "" ? args[5] : ""
        let notes = args.count > 6 && args[6] != "" ? args[6] : ""
        let allDay = args.count > 7 && args[7] == "true"
        
        // Find calendar
        var calendar: EKCalendar?
        if !calName.isEmpty {
            calendar = store.calendars(for: .event).first { 
                $0.title.lowercased().contains(calName.lowercased()) 
            }
        }
        if calendar == nil {
            calendar = store.defaultCalendarForNewEvents
        }
        guard let targetCalendar = calendar else {
            fputs("{\"error\": \"No calendar found\"}\n", stderr)
            exit(1)
        }
        
        // Parse dates
        let formatter = DateFormatter()
        formatter.timeZone = TimeZone.current
        
        var startDate: Date?
        var endDate: Date?
        
        if allDay || startStr.count == 10 {
            formatter.dateFormat = "yyyy-MM-dd"
            startDate = formatter.date(from: String(startStr.prefix(10)))
            if !endStr.isEmpty {
                endDate = formatter.date(from: String(endStr.prefix(10)))
            } else {
                endDate = startDate
            }
        } else {
            formatter.dateFormat = "yyyy-MM-dd HH:mm"
            startDate = formatter.date(from: startStr)
            if !endStr.isEmpty {
                endDate = formatter.date(from: endStr)
            } else if let start = startDate {
                endDate = start.addingTimeInterval(3600)
            }
        }
        
        guard let start = startDate, let end = endDate else {
            fputs("{\"error\": \"Invalid date format\"}\n", stderr)
            exit(1)
        }
        
        // Create event
        let event = EKEvent(eventStore: store)
        event.title = title
        event.startDate = start
        event.endDate = end
        event.calendar = targetCalendar
        event.isAllDay = allDay || startStr.count == 10
        
        if !location.isEmpty { event.location = location }
        if !notes.isEmpty { event.notes = notes }
        
        do {
            try store.save(event, span: .thisEvent)
            let isoFormatter = ISO8601DateFormatter()
            isoFormatter.formatOptions = [.withInternetDateTime]
            print("{\"id\":\"\(event.eventIdentifier ?? "")\",\"title\":\"\(title)\",\"start\":\"\(isoFormatter.string(from: start))\",\"calendar_name\":\"\(targetCalendar.title)\",\"status\":\"created\"}")
        } catch {
            fputs("{\"error\": \"\(error.localizedDescription)\"}\n", stderr)
            exit(1)
        }
      args:
        - "{{params.title}}"
        - "{{params.start}}"
        - "{{params.end}}"
        - "{{params.calendar_id}}"
        - "{{params.location}}"
        - "{{params.description}}"
        - "{{params.all_day | default: false}}"
      response:
        mapping:
          id: ".id"
          title: ".title"
          start: ".start"
          calendar:
            name: ".calendar_name"
          status: ".status"
          connector: "'apple'"

  update:
    label: "Update event"
    description: Update an existing calendar event
    params:
      id: { type: string, required: true, description: "Event ID" }
      title: { type: string, description: "New title" }
      start: { type: string, description: "New start time" }
      end: { type: string, description: "New end time" }
      location: { type: string, description: "New location" }
      description: { type: string, description: "New description" }
      calendar_id: { type: string, description: "Move to different calendar" }
    swift:
      script: |
        import EventKit
        import Foundation
        
        let store = EKEventStore()
        let semaphore = DispatchSemaphore(value: 0)
        var accessGranted = false
        
        if #available(macOS 14.0, *) {
            store.requestFullAccessToEvents { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        } else {
            store.requestAccess(to: .event) { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        }
        semaphore.wait()
        
        guard accessGranted else {
            fputs("{\"error\": \"Calendar access denied\"}\n", stderr)
            exit(1)
        }
        
        let args = CommandLine.arguments
        guard args.count > 1 else {
            fputs("{\"error\": \"Event ID required\"}\n", stderr)
            exit(1)
        }
        
        let uid = args[1]
        let title = args.count > 2 && args[2] != "" ? args[2] : nil
        let startStr = args.count > 3 && args[3] != "" ? args[3] : nil
        let endStr = args.count > 4 && args[4] != "" ? args[4] : nil
        let location = args.count > 5 && args[5] != "" ? args[5] : nil
        let notes = args.count > 6 && args[6] != "" ? args[6] : nil
        let calendarName = args.count > 7 && args[7] != "" ? args[7] : nil
        
        guard let event = store.event(withIdentifier: uid) else {
            fputs("{\"error\": \"Event not found\"}\n", stderr)
            exit(1)
        }
        
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm"
        formatter.timeZone = TimeZone.current
        
        if let t = title { event.title = t }
        if let s = startStr, let d = formatter.date(from: s) { event.startDate = d }
        if let e = endStr, let d = formatter.date(from: e) { event.endDate = d }
        if let l = location { event.location = l }
        if let n = notes { event.notes = n }
        
        if let calName = calendarName {
            if let newCal = store.calendars(for: .event).first(where: { 
                $0.title.lowercased().contains(calName.lowercased()) 
            }) {
                event.calendar = newCal
            } else {
                fputs("{\"error\": \"Calendar not found\"}\n", stderr)
                exit(1)
            }
        }
        
        do {
            try store.save(event, span: .thisEvent)
            print("{\"id\":\"\(event.eventIdentifier ?? uid)\",\"title\":\"\(event.title ?? "")\",\"calendar_name\":\"\(event.calendar.title)\",\"status\":\"updated\"}")
        } catch {
            fputs("{\"error\": \"\(error.localizedDescription)\"}\n", stderr)
            exit(1)
        }
      args:
        - "{{params.id}}"
        - "{{params.title}}"
        - "{{params.start}}"
        - "{{params.end}}"
        - "{{params.location}}"
        - "{{params.description}}"
        - "{{params.calendar_id}}"
      response:
        mapping:
          id: ".id"
          title: ".title"
          calendar:
            name: ".calendar_name"
          status: ".status"
          connector: "'apple'"

  delete:
    label: "Delete event"
    description: Delete a calendar event
    params:
      id: { type: string, required: true, description: "Event ID" }
    swift:
      script: |
        import EventKit
        import Foundation
        
        let store = EKEventStore()
        let semaphore = DispatchSemaphore(value: 0)
        var accessGranted = false
        
        if #available(macOS 14.0, *) {
            store.requestFullAccessToEvents { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        } else {
            store.requestAccess(to: .event) { granted, _ in
                accessGranted = granted
                semaphore.signal()
            }
        }
        semaphore.wait()
        
        guard accessGranted else {
            fputs("{\"error\": \"Calendar access denied\"}\n", stderr)
            exit(1)
        }
        
        let uid = CommandLine.arguments.count > 1 ? CommandLine.arguments[1] : ""
        guard !uid.isEmpty, let event = store.event(withIdentifier: uid) else {
            fputs("{\"error\": \"Event not found\"}\n", stderr)
            exit(1)
        }
        
        let title = event.title ?? "Untitled"
        
        do {
            try store.remove(event, span: .thisEvent)
            print("{\"status\":\"deleted\",\"title\":\"\(title)\"}")
        } catch {
            fputs("{\"error\": \"\(error.localizedDescription)\"}\n", stderr)
            exit(1)
        }
      args:
        - "{{params.id}}"
      response:
        mapping:
          status: ".status"
          title: ".title"
          connector: "'apple'"
